import {RawVariant} from '../precepts';
import {Identity, Func, identityFunc, GetDataType, ExtractOfUnion, strEnum, isPromise} from './util';



// /**
//  * More specific toString();
//  */
// export type Stringable<ReturnType extends string> = {
//     toString(): ReturnType;
// }


// /**
//  * Used in writing cases of a type-first variant.
//  * 
//  * `Variant<'One', {a: number, b: string}>>` generates
//  *  - `{type: 'One', a: number, b: string}`
//  * 
//  * You may write the literals directly, using this is recommended
//  * if you'd like to update the literal as this library updates.
//  * @deprecated
//  */
// export type Variant<
//     Type extends string,
//     Fields extends {} = {},
//     Key extends string = 'type',
// > = Property<Key, Type> & Fields;

/**
 * A valid entry for `variantList`
 */
type validListType = VariantCreator<any, Func, any> | string;

/**
 * Convert entries for a `variantList` to the same type.
 */
type Variantify<T extends validListType> = T extends string ? VariantCreator<T> : T;


export type VariantModuleFromList<T extends validListType> = {
    [P in Variantify<T>['type']]: FilterVariants<Variantify<T>, P>
}

/**
 * Create a variant module based on a list of variants.
 * 
 * @remarks
 * Best way to create groups of pre-existing variants.
 * 
 * @param variants a list of variant creators and `string`s for tags that have no body
 */
export function variantList<T extends validListType>(variants: Array<T>): VariantModuleFromList<T> {
    return variants
        .map((v): VariantCreator<string> => {
            if (typeof v === 'string') {
                return variant(v);
            } else {
                return v as any;
            }
        })
        .reduce((o, v) => ({
            ...o,
            [v.type]: v,
        }), Object.create(null))
}

function safeKeys<O extends {}>(o: O) {
    return Object.keys(o) as (keyof O & string)[];
}


export type ConstrainedRawVariant<F extends Func> = {[type: string]: (...args: [...Parameters<F>, ...any[]]) => ReturnType<F>}
export type PatternedRawVariant<F extends Func> = {[type: string]: F}

/**
 * Patched Constrained Raw Variant
 */
type PatchedCRV<T extends ConstrainedRawVariant<F>, F extends Func> = {
    [P in keyof T]: (...args: Parameters<T[P]>) => Identity<ReturnType<T[P]> & ReturnType<F>>;
}

type CleanResult<T, U> = T extends undefined ? U : T extends Func ? T : T extends object ? U : T;

type FullyFuncRawVariant<V extends RawVariant> = {
    [P in keyof V & string]: CleanResult<V[P], () => {}>
}
export type OutVariant<T extends RawVariant>
    = {[P in (keyof T & string)]: VariantCreator<P, CleanResult<T[P], () => {}>>}
;

/**
 * Create a variant module from an object describing the variant's structure.
 * Each key of the object is a case of the variant. Each value of the object
 * is the constructor function associated with that key. 
 * @param v 
 */
export function variantModule<
    T extends RawVariant,
>(v: T): Identity<OutVariant<T>> {
    return safeKeys(v).reduce((acc, key) => {
        return {
            ...acc,
            [key]: variant(key, typeof v[key] === 'function' ? v[key] as Func : identityFunc),
        };
    }, {} as Identity<OutVariant<T>>);
}

export function constrained<
    T extends ConstrainedRawVariant<F>,
    F extends Func,
>(_constraint_: F, v: T) {
    return v as PatchedCRV<T, F>;
}
export function patterned<
    T extends PatternedRawVariant<F>,
    F extends Func,
>(_constraint_: F, v: T) {
    return v as PatchedCRV<T, F>;
}

/**
 * Take a variant, including some potential `{}` cases
 * and generate an object with those replaced with the `noop` function.
 */
function funcifyRawVariant<V extends RawVariant>(v: V) {
    return safeKeys(v).reduce((acc, cur) => {
        return {
            ...acc,
            [cur]: typeof v[cur] === 'function' ? v[cur] : () => {},
        }
    }, {}) as FullyFuncRawVariant<V>
}

export type AugmentedRawVariant<V extends RawVariant, F extends Func> = {
    [P in keyof V & string]: (...args: Parameters<FullyFuncRawVariant<V>[P]>) => (ReturnType<F> & ReturnType<FullyFuncRawVariant<V>[P]>)
}
/**
 * Expand the functionality of a variant as a whole by tacking on properties
 * generated by a thunk.
 * 
 * Used in conjunction with `variantModule`
 * 
 * ```typescript
 * export const Action = variantModule(augmented(
 *     () => ({created: Date.now()}), 
 *     {
 *         AddTodo: fields<{text: string, due?: number}>(),
 *         UpdateTodo: fields<{todoId: number, text?: string, due?: number, complete?: boolean}>(),
 *     },
 * ));
 * ```
 * @param variantDef 
 * @param f 
 */
export function augmented<T extends RawVariant, F extends (x: OutVariant<T>) => any>(f: F, variantDef: T) {
    const funkyDef = funcifyRawVariant(variantDef);
    return safeKeys(funkyDef).reduce((acc, key) => {
        return {
            ...acc,
            [key]: (...args: Parameters<FullyFuncRawVariant<T>[typeof key]>) => {
                const item = funkyDef[key](...args);
                return {
                    ...f(item),
                    ...item,
                }
            }
        }
    }, {}) as AugmentedRawVariant<T, F>;
}


type ScopedVariant<T extends RawVariant, Scope extends string> = {
    [P in (keyof T & string)]: VariantCreator<`${Scope}__${P}`, CleanResult<T[P], () => {}>>;
}

/**
 * Unstable.
 * @alpha - unstable API
 * @param v 
 * @param _contract 
 */
export function scopedVariant<
    T extends RawVariant,
    Scope extends string,
>(scope: Scope, v: T): Identity<ScopedVariant<T, Scope>> {
    return safeKeys(v).reduce((acc, key) => {
        return {
            ...acc,
            [key]: variant(`${scope}__${key}`, typeof v[key] === 'function' ? v[key] as any : identityFunc),
        };
    }, {} as Identity<ScopedVariant<T, Scope>>);
}



// export type SumType<T extends VariantModule<K>, K extends string = 'type'> = InternalVariantsOf<T, K>[keyof T];
// export type KeyMap<T extends VariantModule<K>, K extends string = 'type'> = {
//     [Label in keyof T]: T[Label] extends VariantCreator<infer TypeStr, Func, K> ? TypeStr : never;
// }
// /**
//  * Extract the key literals of a variant.
//  */
// export type KeysOf<T extends VariantModule<K>, K extends string = 'type'> = KeyMap<T, K>[keyof T];
// /**
//  * Get the valid options for a variant type's names, plus `undefined`.
//  */
// export type TypeNames<T extends VariantModule<K>, K extends string = 'type'> = KeysOf<T, K> | undefined;

// export type VariantOf<
//     T extends VariantModule<K>,
//     TType = undefined,
//     K extends string = 'type'
// > = TType extends undefined ? SumType<T, K> : TType extends KeysOf<T, K> ? ExtractOfUnion<SumType<T, K>, TType, K> : SumType<T, K>;

/**
 * Return an object cache (`{[P]: P}`) of the keys.
 * 
 * An object cache is more useful than an array because you can do
 * constant time checks and you can still reduce to a well-typed
 * array with Object.keys
 * @param variantDef 
 */
export function keys<T extends VariantModule>(variantDef: T): {[P in KeysOf<T>]: P} {
    return strEnum(outputTypes(variantDef)) as any;
}

/**
 * A variant module does not *necessarily* have a 1-1 mapping from
 * the key used to refer to the object (Animal.bird) and the key generated
 * by the variant (ANIMAL_BIRD, @animal/bird, etc.).
 * @param v 
 */
export function keymap<T extends VariantModule<K>, K extends string = 'type'>(v: T): KeyMap<T, K> {
    return Object.keys(v).reduce((acc, key) => {
        return {
            ...acc,
            [key]: v[key].type,
        };
    }, {} as KeyMap<T,K>);
}

// export type Matrix<T extends VariantModule<K>, K extends string = 'type'> = {
//     [P in KeysOf<T, K>]: ExtractOfUnion<SumType<T, K>, P, K>
// }

// /**
//  * Splay a list of variant instances into an object. 
//  */
// export type Flags<T extends VariantModule> = Partial<Matrix<T>>;

// /**
//  * groupBy list of instances on discriminant key. Assumes unique instance per type.
//  * @param flags 
//  * @param typeKey 
//  */
// export function flags<T extends Property<K, string>, K extends string = 'type'>(flags: T[], typeKey?: K): {[P in T[K]]: ExtractOfUnion<T, P, K>} {
//     return flags.reduce((o, v) => ({
//         ...o,
//         [v[typeKey ?? 'type']]: v,
//     }), Object.create(null))
// }

